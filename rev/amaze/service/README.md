# amaze
Таск просит на что-то на ввод и проверяет введенные данные. При прохождении проверки печатает флаг
## Решение
Функция main в декомпиляторе IDA PRO 7.6 выглядит так:
```
void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)
{
  int v3; // er12
  int v4; // ebp
  int v5; // ebx
  char buf[41]; // [rsp+Fh] [rbp-29h] BYREF

  v3 = 415;
  v4 = 0;
  v5 = 1;
  while ( v5 != 198 || v4 != 199 )
  {
    do
    {
      a2 = (char **)buf;
      read(0, buf, 1uLL);
    }
    while ( buf[0] == 10 );
    switch ( buf[0] )
    {
      case 'D':
      case 'd':
        ++v4;
        goto LABEL_8;
      case 'L':
      case 'l':
        --v5;
        goto LABEL_7;
      case 'R':
      case 'r':
        ++v5;
        goto LABEL_8;
      case 'U':
      case 'u':
        --v4;
LABEL_7:
        if ( (v4 | v5) < 0 )
          goto LABEL_10;
LABEL_8:
        a1 = qword_4020[200 * v4 + v5];
        if ( !(unsigned int)sub_12A0(a1) || (--v3, !v3) )
LABEL_10:
          exit(-1);
        return;
      default:
        goto LABEL_10;
    }
  }
  sub_1330(a1, a2, a3);
}
```
По коду можно понять, что всего на ввод программа может принимать символы 'DdLlRrUu'. Каждая их них соответственно означает Down Left Right и Up. Переменная v4 является координатой Y, тогда как переменная v5 является координатой X. Каждый ход выполняется проверка функцией sub_12A0, которой на вход подается некоторое число, которое на самом деле является числом координаты. qword_4020 - является массивом, в котором по координатам лежит число. Функция проверки sub_12A0 выглядит так:
```
_BOOL8 __fastcall sub_12A0(unsigned __int64 a1)
{
  char *v2; // rdi
  char *v3; // rdx
  char v4; // cl
  char *v5; // rax
  unsigned __int64 v6; // rdx
  int v7; // ebx

  v2 = (char *)malloc(0x40uLL);
  v3 = v2 + 63;
  do
  {
    v4 = a1;
    v5 = v3;
    a1 >>= 1;
    *v3-- = (v4 & 1) + 65;
  }
  while ( v5 != v2 );
  v6 = 0LL;
  v7 = 0;
  do
  {
    while ( v2[v6] != 66 || v6 > 0x3D )
    {
      if ( ++v6 == 64 )
        goto LABEL_8;
    }
    v7 += (((__int64)0xDFFFFB15DFFEF9DELL >> v6++) & 1) == 0;
  }
  while ( v6 != 64 );
LABEL_8:
  free(v2);
  return v7 == 13;
}
```
Первый цикл здесь делал из числа бинарную строку, где 0 - 'A', а 1 - 'B'. Далее второй цикл считает единички на некоторых местах. Единички должны стоять на местах [0, 5, 9, 10, 16, 29, 33, 35, 37, 38, 39, 42, 61], при этом не важно, стоят ли они на остальных местах. Таким образом получается проверка
```
def isCell(num):
    return (num & 0x8460800457200004 == 0x8460800457200004)
```
В коде она была искусственно усложнена.
Таким образом, если isCell(num) - True, мы можем ступать на эту координату, иначе, программа прекращает свою работу.
Получается, что у нас есть лабиринт, и если мы достигнем клетки с координатами (198, 199), не сходя на неправильные клетки, то программа выдаст нам флаг, но есть ещё одно условие. Есть возможность сделать только 415 ходов, что означает, что надо найти кратчайший путь, который будет длиной как раз 415 ходов. Для этого надо реализовать BFS, но тут изобретать велосипед особо не надо, потому что можно найти ответ на stackoverflow, в котором будет описан код, который ищет кратчайший путь. Скрипт с решением называется solve.py, однако ему надо скормить файл с номерами клеток. Вы можете попрактиковаться и достать номера сами, или использовать IDAPython скрипт:
`open("kek", 'w').write(str([[ida_bytes.get_qword(i*200+j) for j in range(200)] for i in range(200)]))`

