# pwn1

Подключаясь на заданный сервер с помощью netcat мы видим, что программа выдаёт какое-то шестнадцатеричное значение и предлагает что-то ввести. 
Если запустить данную программу локально в отладчике gdb и выполнить команду `info proc mappings`, можно увидеть, что адрес, который отдаёт нам исполняемый файл принадлежит региону с самим бинарником. 

## Анализ кода
Если открыть программу в декомпиляторе, например IDA Hex-Rays или Ghidra, то мы увидим следующий код.
![изображение](https://user-images.githubusercontent.com/64375994/151363202-74e779e7-d6a4-48ef-b93d-fc4f2a4da6ee.png)

После прочтения этого небольшого кусочка кода мы можем сделать вывод, что программа читает 0x80 байт на стек, где выделено только 8 байт (sizeof(__int64)==8). Следовательно здесь есть уязвимость переполнения буфера на стеке. По эксплутации этой уязвимости есть множество материалов в интернете, откуда решающий может почерпнуть алгоритм эксплуатации. 

Нам нужно "прыгнуть" на адрес функции win, чтобы получить удалённое исполнение кода:

![изображение](https://user-images.githubusercontent.com/64375994/151363632-573adf0d-cd70-4057-8b45-cb5e5f1c9573.png)

После записи 24 мусорных байт на стек, мы можем записать адрес этой функции в порядке little endian. Таким образом таск решён и мы получаем флаг.
